<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Creepy Maze</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', monospace;
            color: #8a0303;
            overflow: hidden;
            cursor: none;
        }
        
        #game-container {
            position: relative;
            width: 600px;
            height: 600px;
        }
        
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        
        @keyframes flash {
            0% { opacity: 1; }
            50% { opacity: 0.2; }
            100% { opacity: 1; }
        }
        
        canvas {
            display: block;
            box-shadow: 0 0 20px rgba(138, 3, 3, 0.7);
            filter: contrast(1.1) brightness(0.9);
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
        
        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            z-index: 200;
        }
        
        #jumpscare-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            opacity: 0;
            pointer-events: none;
            z-index: 300;
            transition: opacity 0.1s ease;
        }
        
        #jumpscare-face {
            width: 80%;
            height: 70%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #game-over-text {
            color: #f00;
            font-size: 48px;
            font-weight: bold;
            margin-top: 20px;
            text-shadow: 0 0 10px #f00;
            letter-spacing: 5px;
            animation: pulse-red 0.5s infinite;
        }
        
        @keyframes pulse-red {
            0% { text-shadow: 0 0 10px #f00; }
            50% { text-shadow: 0 0 30px #f00; }
            100% { text-shadow: 0 0 10px #f00; }
        }
        
        #cursor {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #8a0303;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 0 5px #8a0303;
            mix-blend-mode: lighten;
        }
        
        #message-content {
            color: #8a0303;
            font-size: 24px;
            text-align: center;
            max-width: 80%;
            text-shadow: 0 0 5px #8a0303;
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 0.9; }
            100% { opacity: 0.7; }
        }
        
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 150;
        }
        
        .flicker {
            animation: flicker 8s infinite;
        }
        
        @keyframes flicker {
            0% { opacity: 1; }
            3% { opacity: 0.8; }
            6% { opacity: 1; }
            7% { opacity: 0.6; }
            8% { opacity: 1; }
            9% { opacity: 0.9; }
            10% { opacity: 1; }
            50% { opacity: 1; }
            52% { opacity: 0.7; }
            54% { opacity: 1; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        <div id="hud">Weird Findings: <span id="counter">0</span></div>
        <div class="vignette"></div>
        <div id="message-overlay">
            <div id="message-content"></div>
        </div>
        <div id="jumpscare-overlay">
            <div id="jumpscare-face">
                <svg width="400" height="300" viewBox="0 0 400 300">
                    <path d="M200,50 Q270,30 300,100 Q330,170 200,250 Q70,170 100,100 Q130,30 200,50" fill="#ffb3b3" />
                    <circle cx="150" cy="120" r="25" fill="#000" />
                    <circle cx="250" cy="120" r="25" fill="#000" />
                    <path d="M150 150 Q200 220 250 150" stroke="#500" stroke-width="10" fill="none" />
                    <path d="M170 90 L130 105" stroke="#500" stroke-width="6" />
                    <path d="M230 90 L270 105" stroke="#500" stroke-width="6" />
                    
                    <circle cx="150" cy="120" r="10" fill="#f00" />
                    <circle cx="250" cy="120" r="10" fill="#f00" />
                    <path d="M150 170 Q200 220 250 170" stroke="#f00" stroke-width="5" fill="none" />
                </svg>
            </div>
            <div id="game-over-text">GAME OVER</div>
        </div>
        <div id="cursor"></div>
    </div>

    <script>
        // Game constants
        const CELL_SIZE = 30;
        const GRID_WIDTH = 20;
        const GRID_HEIGHT = 20;
        const CANVAS_WIDTH = CELL_SIZE * GRID_WIDTH;
        const CANVAS_HEIGHT = CELL_SIZE * GRID_HEIGHT;
        
        // Game variables
        let maze = [];
        let playerX = 1;
        let playerY = 1;
        let weirdFindings = 0;
        let weirdThings = [];
        let lastMazeChange = 0;
        let mazeChangeInterval = 30000; // 30 seconds
        let fogOfWar = true;
        let visibleCells = {};
        let mazeExit = { x: 0, y: 0 };
        let mazeExitTrigger = { x: 0, y: 0 };
        let gameOver = false;
        let storyProgress = 0;
        
        // DOM elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const counterElement = document.getElementById('counter');
        const messageOverlay = document.getElementById('message-overlay');
        const messageContent = document.getElementById('message-content');
        
        // Initialize the game
        function initGame() {
            // Initialize the maze grid
            for (let y = 0; y < GRID_HEIGHT; y++) {
                maze[y] = [];
                for (let x = 0; x < GRID_WIDTH; x++) {
                    maze[y][x] = {
                        walls: {
                            top: true,
                            right: true,
                            bottom: true,
                            left: true
                        },
                        visited: false
                    };
                }
            }
            
            // Generate the maze
            generateMaze();
            
            // Place weird things
            placeWeirdThings();
            
            // Place the exit
            placeExit();
            
            // Set up event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('mousemove', handleMouseMove);
            
            // Start the game loop
            gameLoop();
            
            // Show initial message
            showMessage("You wake up in an unfamiliar place. The darkness feels... alive. Your flashlight reveals just enough to navigate. Find the exit, but beware what lurks in this maze...");
        }
        
        // Place the exit and the trigger for the jumpscare
        function placeExit() {
            // Place the exit far from the player's starting position
            let attempts = 0;
            do {
                mazeExit.x = GRID_WIDTH - 2 - Math.floor(Math.random() * 3);
                mazeExit.y = GRID_HEIGHT - 2 - Math.floor(Math.random() * 3);
                attempts++;
            } while ((Math.abs(mazeExit.x - playerX) < 10 || 
                      Math.abs(mazeExit.y - playerY) < 10) && attempts < 20);
            
            // Create a path to the exit
            let x = mazeExit.x, y = mazeExit.y;
            while (x > 1 || y > 1) {
                if (x > 1 && Math.random() < 0.5) {
                    maze[y][x].walls.left = false;
                    maze[y][x-1].walls.right = false;
                    x--;
                } else if (y > 1) {
                    maze[y][x].walls.top = false;
                    maze[y-1][x].walls.bottom = false;
                    y--;
                } else if (x > 1) {
                    maze[y][x].walls.left = false;
                    maze[y][x-1].walls.right = false;
                    x--;
                }
            }
            
            // Place the trigger one step away from the exit
            // Determine which direction to place the trigger based on the walls
            if (!maze[mazeExit.y][mazeExit.x].walls.left) {
                mazeExitTrigger.x = mazeExit.x - 1;
                mazeExitTrigger.y = mazeExit.y;
            } else if (!maze[mazeExit.y][mazeExit.x].walls.top) {
                mazeExitTrigger.x = mazeExit.x;
                mazeExitTrigger.y = mazeExit.y - 1;
            } else if (!maze[mazeExit.y][mazeExit.x].walls.right) {
                mazeExitTrigger.x = mazeExit.x + 1;
                mazeExitTrigger.y = mazeExit.y;
            } else {
                mazeExitTrigger.x = mazeExit.x;
                mazeExitTrigger.y = mazeExit.y + 1;
            }
        }
        
        // Handle mouse movement for the cursor
        function handleMouseMove(event) {
            const cursor = document.getElementById('cursor');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            cursor.style.left = `${x}px`;
            cursor.style.top = `${y}px`;
        }
        
        // Generate a maze using recursive backtracking (DFS)
        function generateMaze() {
            // Reset the maze
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    maze[y][x].walls = {
                        top: true,
                        right: true,
                        bottom: true,
                        left: true
                    };
                    maze[y][x].visited = false;
                    maze[y][x].weird = false;
                }
            }
            
            // Start from a random cell
            let startX = 1 + Math.floor(Math.random() * (GRID_WIDTH - 2));
            let startY = 1 + Math.floor(Math.random() * (GRID_HEIGHT - 2));
            
            // Create a stack for backtracking
            let stack = [];
            
            // Mark the start cell as visited
            maze[startY][startX].visited = true;
            stack.push({ x: startX, y: startY });
            
            // Continue until the stack is empty
            while (stack.length > 0) {
                // Get the current cell
                let current = stack[stack.length - 1];
                
                // Find all unvisited neighbors
                let neighbors = getUnvisitedNeighbors(current.x, current.y);
                
                if (neighbors.length > 0) {
                    // Choose a random neighbor
                    let randomIndex = Math.floor(Math.random() * neighbors.length);
                    let next = neighbors[randomIndex];
                    
                    // Remove the wall between the current cell and the chosen neighbor
                    removeWall(current, next);
                    
                    // Mark the neighbor as visited
                    maze[next.y][next.x].visited = true;
                    
                    // Push the neighbor to the stack
                    stack.push(next);
                } else {
                    // Backtrack
                    stack.pop();
                }
            }
            
            // Reset visited flags for gameplay
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    maze[y][x].visited = false;
                }
            }
            
            // Clear visibility data
            visibleCells = {};
            
            // Set player position
            playerX = 1;
            playerY = 1;
            
            // Add a creepy random pattern in some areas
            addCreepyPatterns();
        }
        
        // Add some creepy patterns to make the maze more interesting
        function addCreepyPatterns() {
            // Add some random "distorted" areas
            for (let i = 0; i < 3; i++) {
                let centerX = 4 + Math.floor(Math.random() * (GRID_WIDTH - 8));
                let centerY = 4 + Math.floor(Math.random() * (GRID_HEIGHT - 8));
                let radius = 2 + Math.floor(Math.random() * 2);
                
                for (let y = centerY - radius; y <= centerY + radius; y++) {
                    for (let x = centerX - radius; x <= centerX + radius; x++) {
                        if (y >= 0 && y < GRID_HEIGHT && x >= 0 && x < GRID_WIDTH) {
                            // Randomly remove or add walls in this area
                            if (Math.random() < 0.4) {
                                if (Math.random() < 0.5 && x > 0) {
                                    maze[y][x].walls.left = !maze[y][x].walls.left;
                                    maze[y][x-1].walls.right = maze[y][x].walls.left;
                                }
                                if (Math.random() < 0.5 && y > 0) {
                                    maze[y][x].walls.top = !maze[y][x].walls.top;
                                    maze[y-1][x].walls.bottom = maze[y][x].walls.top;
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Get all unvisited neighboring cells
        function getUnvisitedNeighbors(x, y) {
            let neighbors = [];
            
            // Check the cell above
            if (y > 0 && !maze[y-1][x].visited) {
                neighbors.push({ x: x, y: y-1, direction: 'top' });
            }
            
            // Check the cell to the right
            if (x < GRID_WIDTH - 1 && !maze[y][x+1].visited) {
                neighbors.push({ x: x+1, y: y, direction: 'right' });
            }
            
            // Check the cell below
            if (y < GRID_HEIGHT - 1 && !maze[y+1][x].visited) {
                neighbors.push({ x: x, y: y+1, direction: 'bottom' });
            }
            
            // Check the cell to the left
            if (x > 0 && !maze[y][x-1].visited) {
                neighbors.push({ x: x-1, y: y, direction: 'left' });
            }
            
            return neighbors;
        }
        
        // Remove the wall between two cells
        function removeWall(cell1, cell2) {
            if (cell1.y > cell2.y) {
                maze[cell1.y][cell1.x].walls.top = false;
                maze[cell2.y][cell2.x].walls.bottom = false;
            } else if (cell1.y < cell2.y) {
                maze[cell1.y][cell1.x].walls.bottom = false;
                maze[cell2.y][cell2.x].walls.top = false;
            } else if (cell1.x > cell2.x) {
                maze[cell1.y][cell1.x].walls.left = false;
                maze[cell2.y][cell2.x].walls.right = false;
            } else if (cell1.x < cell2.x) {
                maze[cell1.y][cell1.x].walls.right = false;
                maze[cell2.y][cell2.x].walls.left = false;
            }
        }
        
        // Place weird things in the maze
        function placeWeirdThings() {
            // Clear existing weird things
            weirdThings = [];
            
            // Add some weird things to find
            const numWeirdThings = 5 + Math.floor(Math.random() * 5); // 5-10 weird things
            
            for (let i = 0; i < numWeirdThings; i++) {
                let x, y;
                
                // Find a valid location (not where the player is and not where another weird thing is)
                do {
                    x = 1 + Math.floor(Math.random() * (GRID_WIDTH - 2));
                    y = 1 + Math.floor(Math.random() * (GRID_HEIGHT - 2));
                } while ((x === playerX && y === playerY) || weirdThingAt(x, y));
                
                // Create a weird thing
                weirdThings.push({
                    x: x,
                    y: y,
                    type: Math.floor(Math.random() * 5), // Different types of weird things
                    found: false
                });
            }
        }
        
        // Check if there's a weird thing at the given coordinates
        function weirdThingAt(x, y) {
            return weirdThings.some(thing => thing.x === x && thing.y === y);
        }
        
        // Get the weird thing at the given coordinates
        function getWeirdThingAt(x, y) {
            return weirdThings.find(thing => thing.x === x && thing.y === y);
        }
        
        // Handle key presses
        function handleKeyDown(event) {
            // Don't handle input if message is showing or if game is over
            if (parseFloat(messageOverlay.style.opacity || 0) > 0 || gameOver) {
                return;
            }
            
            let newX = playerX;
            let newY = playerY;
            
            switch (event.key) {
                case 'ArrowUp':
                    if (!maze[playerY][playerX].walls.top) {
                        newY--;
                    }
                    break;
                case 'ArrowRight':
                    if (!maze[playerY][playerX].walls.right) {
                        newX++;
                    }
                    break;
                case 'ArrowDown':
                    if (!maze[playerY][playerX].walls.bottom) {
                        newY++;
                    }
                    break;
                case 'ArrowLeft':
                    if (!maze[playerY][playerX].walls.left) {
                        newX--;
                    }
                    break;
            }
            
            // If the player moved, update the position
            if (newX !== playerX || newY !== playerY) {
                playerX = newX;
                playerY = newY;
                
                // Mark current position as visited (for fog of war)
                updateVisibility();
                
                // Check for exit or jumpscare trigger
                checkExitTrigger();
                
                // Only do these checks if the game is still running
                if (!gameOver) {
                    // Check for weird things
                    checkWeirdThings();
                    
                    // Check if it's time to change the maze
                    checkMazeChange();
                    
                    // Progress the narrative based on exploration
                    progressNarrative();
                }
            }
        }
        
        // Check if the player has reached the exit trigger or exit
        function checkExitTrigger() {
            // If player is at the exit trigger position
            if (playerX === mazeExitTrigger.x && playerY === mazeExitTrigger.y) {
                // Trigger the jumpscare
                triggerJumpscare();
            }
            
            // If player is at the actual exit
            if (playerX === mazeExit.x && playerY === mazeExit.y) {
                // Show game over with different message
                showMessage("You've reached the exit, but at what cost? The darkness lingers...");
                setTimeout(() => {
                    showGameOver();
                }, 2000);
            }
        }
        
        // Trigger the jumpscare effect
        function triggerJumpscare() {
            // Play a sound (if available)
            // Set game over flag
            gameOver = true;
            
            // Show the jumpscare overlay
            const jumpscare = document.getElementById('jumpscare-overlay');
            const jumpscareSound = new Audio('data:audio/wav;base64,UklGRjIAAABXQVZFZm10IBIAAAABAAEAQB8AAEAfAAABAAgAAABMYXZmNTkuMzIuMTAzAAAAAAAAAAAAAA==');
            
            // Flash the jumpscare
            jumpscare.style.opacity = '1';
            
            // Try to play sound
            try {
                jumpscareSound.play();
            } catch (e) {
                console.log("Sound couldn't play, continuing without sound");
            }
            
            // Shake the screen
            const gameContainer = document.getElementById('game-container');
            gameContainer.style.animation = 'shake 0.5s';
            
            // Apply fast flashing
            canvas.style.animation = 'flash 0.1s infinite';
            
            // Stop the animations and keep showing the jumpscare
            setTimeout(() => {
                gameContainer.style.animation = '';
                canvas.style.animation = '';
                // Keep the jumpscare visible
            }, 1000);
        }
        
        // Show game over screen
        function showGameOver() {
            const jumpscare = document.getElementById('jumpscare-overlay');
            jumpscare.style.opacity = '1';
            gameOver = true;
        }
        
        // Progress the narrative based on exploration and findings
        function progressNarrative() {
            // Base narrative progression on number of weird findings and exploration progress
            if (weirdFindings === 3 && storyProgress === 0) {
                showMessage("The objects seem connected somehow. Your head begins to ache as whispers grow louder...");
                storyProgress = 1;
            } else if (weirdFindings >= 5 && storyProgress === 1) {
                showMessage("Something's following you. Don't look back. Find the exit BEFORE it finds you.");
                storyProgress = 2;
                
                // Make the maze start changing more frequently
                mazeChangeInterval = 15000;
            }
            
            // Random narrative moments
            if (Math.random() < 0.01 && storyProgress >= 1) {
                const narrativeMessages = [
                    "Was that shadow there before?",
                    "The air feels colder here.",
                    "You hear faint scratching sounds from the walls.",
                    "Something whispers your name from behind you.",
                    "The walls seem to breathe."
                ];
                
                showMessage(narrativeMessages[Math.floor(Math.random() * narrativeMessages.length)]);
            }
        }
        
        // Update the visible cells for fog of war effect
        function updateVisibility() {
            // Mark the current cell as visible
            visibleCells[`${playerX},${playerY}`] = true;
            
            // Mark adjacent cells as visible
            if (!maze[playerY][playerX].walls.top) {
                visibleCells[`${playerX},${playerY-1}`] = true;
            }
            if (!maze[playerY][playerX].walls.right) {
                visibleCells[`${playerX+1},${playerY}`] = true;
            }
            if (!maze[playerY][playerX].walls.bottom) {
                visibleCells[`${playerX},${playerY+1}`] = true;
            }
            if (!maze[playerY][playerX].walls.left) {
                visibleCells[`${playerX-1},${playerY}`] = true;
            }
        }
        
        // Check for weird things at the player's position
        function checkWeirdThings() {
            const weirdThing = getWeirdThingAt(playerX, playerY);
            
            if (weirdThing && !weirdThing.found) {
                weirdThing.found = true;
                weirdFindings++;
                
                // Update the counter
                counterElement.textContent = weirdFindings;
                
                // Show a message
                showMessage(getWeirdMessage(weirdThing.type));
                
                // Apply a weird effect
                applyWeirdEffect(weirdThing.type);
            }
        }
        
        // Get a weird message based on the type
        function getWeirdMessage(type) {
            const messages = [
                "You found an old doll with missing eyes. It whispers something you can't quite hear.",
                "A small music box plays a haunting melody that seems to come from everywhere at once.",
                "A mirror shows your reflection, but it doesn't move when you do.",
                "You found ancient symbols carved into the wall. They seem to shift when you look away.",
                "A pocket watch ticks backwards. The temperature around you drops noticeably."
            ];
            
            return messages[type % messages.length];
        }
        
        // Apply a weird effect based on the type
        function applyWeirdEffect(type) {
            switch (type) {
                case 0: // Brief flicker
                    canvas.classList.add('flicker');
                    setTimeout(() => {
                        canvas.classList.remove('flicker');
                    }, 5000);
                    break;
                case 1: // Maze slightly changes
                    changeMazePart();
                    break;
                case 2: // Fog of war temporarily removed
                    const fogBackup = fogOfWar;
                    fogOfWar = false;
                    setTimeout(() => {
                        fogOfWar = fogBackup;
                    }, 3000);
                    break;
                case 3: // Distorted view
                    canvas.style.filter = 'contrast(1.2) brightness(0.8) hue-rotate(30deg)';
                    setTimeout(() => {
                        canvas.style.filter = 'contrast(1.1) brightness(0.9)';
                    }, 5000);
                    break;
                case 4: // Something follows you
                    // This will be handled in the game loop
                    break;
            }
        }
        
        // Change a part of the maze
        function changeMazePart() {
            // Find an area to change
            let centerX = Math.max(3, Math.min(GRID_WIDTH - 3, playerX + (Math.random() < 0.5 ? -1 : 1) * (2 + Math.floor(Math.random() * 3))));
            let centerY = Math.max(3, Math.min(GRID_HEIGHT - 3, playerY + (Math.random() < 0.5 ? -1 : 1) * (2 + Math.floor(Math.random() * 3))));
            
            // Change some walls in a small area
            for (let y = centerY - 1; y <= centerY + 1; y++) {
                for (let x = centerX - 1; x <= centerX + 1; x++) {
                    if (y >= 0 && y < GRID_HEIGHT && x >= 0 && x < GRID_WIDTH) {
                        // Don't modify the outer walls
                        if (y > 0 && x > 0 && y < GRID_HEIGHT - 1 && x < GRID_WIDTH - 1) {
                            // Randomly modify walls
                            if (Math.random() < 0.5) {
                                // Toggle a random wall
                                let wall = ['top', 'right', 'bottom', 'left'][Math.floor(Math.random() * 4)];
                                
                                // Toggle the wall and its neighbor's corresponding wall
                                let neighborX = x + (wall === 'right' ? 1 : (wall === 'left' ? -1 : 0));
                                let neighborY = y + (wall === 'bottom' ? 1 : (wall === 'top' ? -1 : 0));
                                
                                if (neighborY >= 0 && neighborY < GRID_HEIGHT && neighborX >= 0 && neighborX < GRID_WIDTH) {
                                    maze[y][x].walls[wall] = !maze[y][x].walls[wall];
                                    
                                    // Update the neighbor's corresponding wall
                                    let oppositeWall = {
                                        'top': 'bottom',
                                        'right': 'left',
                                        'bottom': 'top',
                                        'left': 'right'
                                    }[wall];
                                    
                                    maze[neighborY][neighborX].walls[oppositeWall] = maze[y][x].walls[wall];
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Check if it's time to change the maze
        function checkMazeChange() {
            const currentTime = Date.now();
            
            if (currentTime - lastMazeChange > mazeChangeInterval) {
                lastMazeChange = currentTime;
                
                // Show a message
                showMessage("The maze shifts around you...");
                
                // Change part of the maze
                setTimeout(() => {
                    // Make sure player position isn't changed
                    let oldPlayerX = playerX;
                    let oldPlayerY = playerY;
                    
                    // Regenerate a small part of the maze or change some walls
                    if (Math.random() < 0.3) {
                        // Major change - regenerate the maze but keep player position
                        generateMaze();
                        playerX = oldPlayerX;
                        playerY = oldPlayerY;
                    } else {
                        // Minor change - just change some walls
                        for (let i = 0; i < 5; i++) {
                            changeMazePart();
                        }
                    }
                    
                    // Place new weird things
                    placeWeirdThings();
                }, 1000);
            }
        }
        
        // Show a message overlay
        function showMessage(message) {
            messageContent.textContent = message;
            messageOverlay.style.opacity = '1';
            messageOverlay.classList.add('pulse');
            
            setTimeout(() => {
                messageOverlay.style.opacity = '0';
                messageOverlay.classList.remove('pulse');
            }, 3000);
        }
        
        // Game loop
        function gameLoop() {
            // Clear the canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw the maze
            drawMaze();
            
            // Draw the player
            drawPlayer();
            
            // Draw weird things
            drawWeirdThings();
            
            // Request the next frame
            requestAnimationFrame(gameLoop);
        }
        
        // Draw the maze
        function drawMaze() {
            // Set the line style
            ctx.strokeStyle = '#8a0303';
            ctx.lineWidth = 2;
            
            // Draw each cell
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    // Skip if using fog of war and cell is not visible
                    if (fogOfWar && !visibleCells[`${x},${y}`]) {
                        continue;
                    }
                    
                    // Set the fill style based on distance from player for a gradient effect
                    const distance = Math.sqrt(Math.pow(x - playerX, 2) + Math.pow(y - playerY, 2));
                    const alpha = fogOfWar ? Math.max(0, 1 - distance / 5) : 1;
                    
                    // Cell position
                    const cellX = x * CELL_SIZE;
                    const cellY = y * CELL_SIZE;
                    
                    // Fill the cell with a dark color
                    ctx.fillStyle = `rgba(20, 20, 20, ${alpha})`;
                    ctx.fillRect(cellX, cellY, CELL_SIZE, CELL_SIZE);
                    
                    // Draw the walls
                    const cell = maze[y][x];
                    
                    // Top wall
                    if (cell.walls.top) {
                        ctx.beginPath();
                        ctx.moveTo(cellX, cellY);
                        ctx.lineTo(cellX + CELL_SIZE, cellY);
                        ctx.stroke();
                    }
                    
                    // Right wall
                    if (cell.walls.right) {
                        ctx.beginPath();
                        ctx.moveTo(cellX + CELL_SIZE, cellY);
                        ctx.lineTo(cellX + CELL_SIZE, cellY + CELL_SIZE);
                        ctx.stroke();
                    }
                    
                    // Bottom wall
                    if (cell.walls.bottom) {
                        ctx.beginPath();
                        ctx.moveTo(cellX, cellY + CELL_SIZE);
                        ctx.lineTo(cellX + CELL_SIZE, cellY + CELL_SIZE);
                        ctx.stroke();
                    }
                    
                    // Left wall
                    if (cell.walls.left) {
                        ctx.beginPath();
                        ctx.moveTo(cellX, cellY);
                        ctx.lineTo(cellX, cellY + CELL_SIZE);
                        ctx.stroke();
                    }
                }
            }
        }
        
        // Draw the player
        function drawPlayer() {
            const centerX = playerX * CELL_SIZE + CELL_SIZE / 2;
            const centerY = playerY * CELL_SIZE + CELL_SIZE / 2;
            const radius = CELL_SIZE / 3;
            
            // Draw player circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fillStyle = '#aaa';
            ctx.fill();
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Draw eyes
            const eyeOffset = radius * 0.4;
            const eyeRadius = radius * 0.2;
            
            ctx.beginPath();
            ctx.arc(centerX - eyeOffset, centerY - eyeOffset, eyeRadius, 0, Math.PI * 2);
            ctx.arc(centerX + eyeOffset, centerY - eyeOffset, eyeRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#000';
            ctx.fill();
        }
        
        // Draw weird things
        function drawWeirdThings() {
            weirdThings.forEach(thing => {
                // Skip if the thing has been found or is not visible
                if (thing.found || (fogOfWar && !visibleCells[`${thing.x},${thing.y}`])) {
                    return;
                }
                
                const centerX = thing.x * CELL_SIZE + CELL_SIZE / 2;
                const centerY = thing.y * CELL_SIZE + CELL_SIZE / 2;
                const size = CELL_SIZE * 0.4;
                
                // Draw based on type
                switch (thing.type) {
                    case 0: // Doll
                        ctx.fillStyle = '#d68c78';
                        ctx.beginPath();
                        ctx.arc(centerX, centerY - size * 0.3, size * 0.4, 0, Math.PI * 2); // Head
                        ctx.fill();
                        
                        ctx.fillStyle = '#a33';
                        ctx.fillRect(centerX - size * 0.3, centerY, size * 0.6, size * 0.8); // Body
                        break;
                        
                    case 1: // Music box
                        ctx.fillStyle = '#a30';
                        ctx.fillRect(centerX - size * 0.5, centerY - size * 0.3, size, size * 0.6); // Box
                        
                        ctx.strokeStyle = '#dd0';
                        ctx.beginPath();
                        ctx.arc(centerX, centerY - size * 0.3, size * 0.3, 0, Math.PI, true); // Handle
                        ctx.stroke();
                        break;
                        
                    case 2: // Mirror
                        ctx.fillStyle = '#777';
                        ctx.fillRect(centerX - size * 0.4, centerY - size * 0.6, size * 0.8, size * 1.2); // Frame
                        
                        ctx.fillStyle = '#acd';
                        ctx.fillRect(centerX - size * 0.3, centerY - size * 0.5, size * 0.6, size); // Glass
                        break;
                        
                    case 3: // Symbols
                        ctx.fillStyle = '#550';
                        
                        // Draw random symbols
                        for (let i = 0; i < 5; i++) {
                            const symbolX = centerX + (Math.random() - 0.5) * size;
                            const symbolY = centerY + (Math.random() - 0.5) * size;
                            
                            ctx.beginPath();
                            if (i % 2 === 0) {
                                ctx.arc(symbolX, symbolY, size * 0.15, 0, Math.PI * 2);
                            } else {
                                ctx.moveTo(symbolX, symbolY - size * 0.15);
                                ctx.lineTo(symbolX + size * 0.15, symbolY + size * 0.15);
                                ctx.lineTo(symbolX - size * 0.15, symbolY + size * 0.15);
                                ctx.closePath();
                            }
                            ctx.fill();
                        }
                        break;
                        
                    case 4: // Pocket watch
                        ctx.fillStyle = '#cb8';
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, size * 0.5, 0, Math.PI * 2); // Watch body
                        ctx.fill();
                        
                        ctx.strokeStyle = '#333';
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(centerX, centerY - size * 0.3); // Hour hand
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(centerX + size * 0.2, centerY); // Minute hand
                        ctx.stroke();
                        break;
                }
            });
        }
        
        // Start the game when the page loads
        window.onload = initGame;
    </script>
</body>
</html>